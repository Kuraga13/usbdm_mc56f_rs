



Option version API


fn set_vdd(&self, power: u8 ) -> Result<(), Error>
{
    match &self.usb_device
    {   
    Some(usb_device) => usb_device.set_vdd(power)?,

    None => panic!("usb_device not found!")
    } 

    Ok(())
    
}




///OLD Code in main:
async fn test_main() {

  let usb_device =  find_usbdm().expect("Usbdm not found!");
  let mut usb_interface = UsbInterface::new(usb_device).expect("Usbdm found but, cant' be configured");
  usb_interface.print_UsbInterface();    
//  let version = usb_interface
  //.get_bdm_version().expect("Error on get bdm ver");

//  version.check_version().expect("Error on check bdm ver");
 // version.print_version();

 //usb_interface.set_vdd(Vdd::BDM_TARGET_VDD_ENABLE);
  let mut programmer = UsbdmProgrammer::new(usb_interface);
  programmer.refresh_feedback();
  programmer.set_vdd(Vdd::BDM_TARGET_VDD_5V);
  programmer.refresh_feedback();
  programmer.print_usbdm_programmer().unwrap();
  programmer.set_vdd(Vdd::BDM_TARGET_VDD_OFF);
  //programmer.set_vdd(Vdd::BDM_TARGET_VDD_DISABLE);
  //programmer.set_vdd(Vdd::BDM_TARGET_VDD_DISABLE);
  programmer.refresh_feedback();
  programmer.print_usbdm_programmer().unwrap();
  programmer.refresh_feedback();
  programmer.print_usbdm_programmer().unwrap();
 // let feedback = programmer.refresh_feedback();
//let printer = programmer.print_usbdm_programmer().unwrap();
  
}


  // NEW!!!
// example
//  
//    let target = TargetDsc::from_xml(target: from_user_input, options : from_user_select)
//    .setup_usbdm(programmer)?        // setup vdd, speed, set target,
//    .connect()?                      // reset, init jtag, read id code, enable_once
//    .read_memory(buffer: read_buff : Vec<u8>)?
//    
//    

//   



pub struct UsbdmProgrammer {

usb_device  : UsbInterface,


capabilities : Capabilities,
feedback     : FeedBack,
//jtag_buffer_size : u32,



//state_from_bdm : BdmStatus,



}








//Read IDCODE from JTAG TAP
//
//@param idCode   - 32-bit IDCODE returned from TAP
//@param resetTAP - Optionally resets the TAP to RUN-TEST/IDLE before reading IDCODE
//                  This will enable the MASTER TAP!
//
// @note - resetTAP=true will enable the Master TAP & disable the Code TAP
// @note - Leaves Core TAP in RUN-TEST/IDLE
//
//USBDM_ErrorCode readIDCODE(uint32_t *idCode, uint8_t commandRegLength, int resetTAP) {
//   LOGGING_Q;
//   uint8_t readCoreIdCodeSequence[] = {
//      (uint8_t)JTAG_TEST_LOGIC_RESET,                          // Reset TAP
  // (uint8_t)  JTAG_REPEAT_Q(TEST_LOGIC_RESET_RECOVERY_NOPS), // ~2.26ms
  // (uint8_t)     JTAG_NOP,
  // (uint8_t)  JTAG_END_REPEAT,
//       (uint8_t)JTAG_MOVE_IR_SCAN,                              // Write IDCODE command to IR
//       (uint8_t)JTAG_SET_EXIT_SHIFT_DR,
//       (uint8_t)JTAG_SHIFT_OUT_Q(commandRegLength), (uint8_t)JTAG_IDCODE_COMMAND,
//       (uint8_t)JTAG_SET_EXIT_IDLE,                             // Read IDCODE from DR
//       (uint8_t)JTAG_SHIFT_IN_Q(32),
//       (uint8_t)JTAG_END
//    };
// 
//   JTAG32 idcode(0,32);
//  USBDM_ErrorCode rc;
//
//   if (resetTAP)
//      readCoreIdCodeSequence[0] = JTAG_TEST_LOGIC_RESET;
//   else
//      readCoreIdCodeSequence[0] = JTAG_NOP;
//
//   rc = executeJTAGSequence(sizeof(readCoreIdCodeSequence), readCoreIdCodeSequence,
//                            4, idcode.getData(32), false);
//   if (rc != BDM_RC_OK) {
//      log.print("Failed, reason = %s\n", USBDM_GetErrorString(rc));
//      return rc;
//   }
//  log.print("IDCODE = %s\n", idcode.toString());
//   *idCode = idcode;

//   return rc;
//}







































 
  


    pub fn set_vdd(&mut self, power: Vdd ) -> Result<(), Error>{
      
      let mut usb_buf  = [0; 4];
      let command = "CMD_USBDM_SET_VDD".to_string();

      usb_buf[0] = 4;
      usb_buf[1] = BDMCommands::CMD_USBDM_SET_VDD;
      usb_buf[2] = power;  
      usb_buf[3] = power;  

      let bit = 0x80;
      let bitter = usb_buf[1] | bit;
      usb_buf[1] = bitter;

      self.write(&usb_buf,1500)?;                                    // write command
      let answer = self.read().expect("Can't read answer");          // read status from bdm
      self.check_usbm_return_code(command, &answer)?;               // check is status ok
      Ok(())
    }


    pub fn set_bdm_vdd_off(&mut self) -> Result<Vec<u8>, Error>{
      
      let mut usb_buf  = [0; 4];
      let command = "CMD_USBDM_SET_VDD".to_string();
      
      usb_buf[0] = 4;
      usb_buf[1] = BDMCommands::CMD_USBDM_SET_VDD;
      usb_buf[2] = vdd::BDM_TARGET_VDD_OFF;  
      usb_buf[3] = vdd::BDM_TARGET_VDD_OFF;  
      
      let bit = 0x80;
      let bitter = usb_buf[1] | bit;
      usb_buf[1] = bitter;

      self.write(&usb_buf,1500)?;                                    // write command
      let answer = self.read().expect("Can't read answer");          // read status from bdm
      self.check_usbm_return_code(command, &answer)?;               // check is status ok
      Ok(answer)
    }

    /// `execute_jtag_sequence`
    /// 
    ///  `param`
    /// 
    ///  `jtag_lenght` - JTAG sequence length. need in u8
    /// 
    ///  `jtag_sequence` - slice &u8 with jtag states-instructions
    /// 
    ///  `answer_lenght` - lenght of answer we wan't receive from target 
    /// 
    pub fn execute_jtag_sequence(
        &mut self, 
        jtag_seq_lenght : u8, 
        jtag_sequence : &[u8],
        answer_lenght : u8,
    ) -> Result<Vec<u8>, Error>{
      
        let mut usb_buf  = [0; ..];
        let command = "CMD_USBDM_JTAG_EXECUTE_SEQUENCE".to_string();
         
        usb_buf[1] = BDMCommands::CMD_USBDM_JTAG_EXECUTE_SEQUENCE;
        usb_buf[2] = answer_lenght;  
        usb_buf[3] = jtag_seq_lenght;  
        usb_buf[4..] = jtag_sequence;
        
        usb_buf[0] = usb_buf.len() as u8;

        let bit = 0x80;
        let bitter = usb_buf[1] | bit;
        usb_buf[1] = bitter;
  
        self.write(&usb_buf,1500)?;                                    // write command
        let answer = self.read().expect("Can't read answer");          // read status from bdm
        self.check_usbm_return_code(command, &answer)?;               // check is status ok
        Ok(answer)


      
    }

    pub fn read_id_code(&mut self) -> Result<Vec<u8>, Error>{
      
        let answer_lenght       = 4;
        let mut jtag_sequenece  = [0..];

        self.execute_jtag_sequence(   )
  //    rc = executeJTAGSequence(sizeof(readCoreIdCodeSequence), readCoreIdCodeSequence,
      //  4, idcode.getData(32), false); 
    }





}





// to usbdm obj

// jtag exec seq
// jtag read_write
// jtag reset
// jtag shift ir
// jtag write

// to target obj

// read_id_code
// enable core tap
// target_debug requees
// enableONCE
// read, write memory


/// Верхний уровень - главный объект от которого надо плясать
/// `mc56f`
struct TargetDsc  
{

// TODO
//Programmer: UsbdmProgrammer <T: rusb::UsbContext>
name          : String,
begin_address : u32,
end_address   : u32,
memory_size   : u32,

power_voltage : BdmVdd,
speed         : u8,


}

// Connect, Read, Write, Erase, 
impl TargetDsc for UsbdmProgrammer {


fn setup(//TODO - param from XML list?)
{
  unimplemented!
}

fn connect(&self)       -> Result<(), Error>{
  unimplemented!

}

fn read_memory(&self)   -> Result<Vec<u8>, Error>{
  unimplemented!

}

fn write_memory(&self)  -> Result<Vec<u8>, Error>{
  unimplemented!

}

fn erase(&self)         -> Result<(), Error>{
  unimplemented!

}


}